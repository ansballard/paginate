{"version":3,"sources":["paginate.js"],"names":["that","numberisInteger","value","isFinite","Math","floor","paginate","countPerPage","contentAsFunction","page","count","i","getContent","setCount","newCount","this","getVisibleContent","setPage","newPage","getNumPages","getCount","getPage","visibleList","content","startIndex","slice","getPages","pageList","numPages","push","index","first","last","length","ceil","getIsFirstPage","getIsLastPage","firstPage","prevPage","nextPage","lastPage","define","amd","module","exports"],"mappings":"CAqBC,SAASA,GACT,YAyJA,SAASC,GAAgBC,GACxB,MAAwB,gBAAVA,IACbC,SAASD,IACTE,KAAKC,MAAMH,KAAWA,EA3JxB,GAAII,GAAW,SAAkBC,EAAcC,GAC9C,GAAIC,GAAO,EACPC,EAAQ,EACRC,EAAI,CACR,MAAIV,EAAgBM,IAAiBA,EAAe,GAGnD,KAAM,oDAFNG,GAAQH,CAIT,IAAIK,GAAaJ,CAEjB,QAMCK,SAAU,SAA0BC,GACnC,KAAIb,EAAgBa,IAAaA,EAAW,GAG3C,KAAM,oDAEP,OAJCJ,GAAQI,EAIFC,KAAKC,qBAObC,QAAS,SAAyBC,GACjC,KAAIjB,EAAgBiB,IAAYA,GAAW,GAAKA,EAAUH,KAAKI,eAG9D,KAAM,iDAAmDJ,KAAKI,aAE/D,OAJCV,GAAOS,EAIDH,KAAKC,qBAKbI,SAAU,WACT,MAAOV,IAKRW,QAAS,WACR,MAAOZ,IAORO,kBAAmB,WAClB,GAAIM,MACAC,EAAUX,GACVH,IAAQM,KAAKI,gBAChBV,EAAO,EAER,IAAIe,GAAaf,EAAOC,CAExB,OADAY,GAAcC,EAAQE,MAAMD,EAAYA,EAAad,IAQtDgB,SAAU,WACT,GAAIC,MACAJ,EAAUX,IACVgB,EAAWb,KAAKI,aACpB,KAAKR,EAAI,EAAOiB,EAAJjB,EAAcA,IACzBgB,EAASE,MACRnB,MAASA,EACToB,MAASnB,EACToB,MAAe,IAANpB,EACTqB,KAAQrB,IAAMiB,EAAW,GAM3B,OAHID,GAASM,OAAS,IACrBN,EAASA,EAASM,OAAS,GAAGvB,MAAQa,EAAQU,OAASvB,GAEjDiB,GAKRR,YAAa,WACZ,MAAOf,MAAK8B,KAAKtB,IAAaqB,OAASvB,IAKxCyB,eAAgB,WACf,MAAgB,KAAT1B,GAKR2B,cAAe,WACd,MAAO3B,KAASM,KAAKI,cAAgB,GAMtCkB,UAAW,WAEV,MADA5B,GAAO,EACAM,KAAKC,qBAObsB,SAAU,WAET,MADA7B,GAAQM,KAAKoB,iBAA8B1B,EAAXA,EAAO,EAChCM,KAAKC,qBAObuB,SAAU,WAET,MADA9B,GAAQM,KAAKqB,gBAA6B3B,EAAXA,EAAO,EAC/BM,KAAKC,qBAMbwB,SAAU,WAET,MADA/B,GAAOM,KAAKI,cAAgB,EACrBJ,KAAKC,sBAKO,mBAAXyB,SAAyBA,OAAOC,IAC1CD,OAAO,WACN,MAAOnC,KAEoB,mBAAXqC,SAA0BA,OAAOC,QAClDD,OAAOC,QAAUtC,EAEjBN,EAAKM,SAAWA,GAShBS","file":"paginate.min.js","sourcesContent":["// paginate.js\n// ==\n// A dependency-free node module to handle data pagination\n//\n// [@ansballard/paginate](https://www.npmjs.com/package/@ansballard/paginate)\n//\n// [MIT License](http://opensource.org/licenses/MIT)\n\n// Paginate( int, fn )\n// ==\n// The constructor takes two parameters, both required. The first is\n// the number of items to return per page. The second is a function\n// that returns the data set to be paginated, as an array.\n// ```javascript\n//   var paginatedList = paginate(\n//     5,\n//     function() {\n//       return [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"];\n//     }\n//   ); // Only [\"a\", \"b\", \"c\", \"d\", \"e\"] will be returned\n// ```\n(function(that) {\n\t\"use strict\";\n\tvar paginate = function paginate(countPerPage, contentAsFunction) {\n\t\tvar page = 0;\n\t\tvar count = 0;\n\t\tvar i = 0;\n\t\tif (numberisInteger(countPerPage) && countPerPage > 0) {\n\t\t\tcount = countPerPage;\n\t\t} else {\n\t\t\tthrow \"Paginate count per page must be a positive integer\";\n\t\t}\n\t\tvar getContent = contentAsFunction;\n\n\t\treturn {\n\t\t\t// setCount( int )\n\t\t\t// ==\n\t\t\t// Sets the number of items to return per page to the given parameter.\n\t\t\t// Will throw an exception if the parameter is `NaN` or negative.\n\t\t\t// Returns the current visible content.\n\t\t\tsetCount: function paginateSetCount(newCount) {\n\t\t\t\tif (numberisInteger(newCount) && newCount > 0) {\n\t\t\t\t\tcount = newCount;\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Paginate count per page must be a positive integer\";\n\t\t\t\t}\n\t\t\t\treturn this.getVisibleContent();\n\t\t\t},\n\t\t\t// setPage( int )\n\t\t\t// ==\n\t\t\t// Sets the current page index to the given parameter.\n\t\t\t// Will throw an exception if the parameter is `NaN` or outside the range of 0 and `getNumPages()`.\n\t\t\t// Returns the current visible content.\n\t\t\tsetPage: function paginateSetPage(newPage) {\n\t\t\t\tif (numberisInteger(newPage) && newPage >= 0 && newPage < this.getNumPages()) {\n\t\t\t\t\tpage = newPage;\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Paginate page must be between 0 and numPages: \" + this.getNumPages();\n\t\t\t\t}\n\t\t\t\treturn this.getVisibleContent();\n\t\t\t},\n\t\t\t// getCount()\n\t\t\t// ==\n\t\t\t// Returns the current number of items returned per page.\n\t\t\tgetCount: function paginateGetCount() {\n\t\t\t\treturn count;\n\t\t\t},\n\t\t\t// getPage()\n\t\t\t// ==\n\t\t\t// Returns the current page index.\n\t\t\tgetPage: function paginateGetPage() {\n\t\t\t\treturn page;\n\t\t\t},\n\t\t\t// getVisibleContent()\n\t\t\t// ==\n\t\t\t// Returns a list of the currently visible content, based on\n\t\t\t// page index, item count per page, and the function passed\n\t\t\t// to the constructor.\n\t\t\tgetVisibleContent: function paginateGetVisibleContent() {\n\t\t\t\tvar visibleList = [];\n\t\t\t\tvar content = getContent();\n\t\t\t\tif (page >= this.getNumPages()) {\n\t\t\t\t\tpage = 0;\n\t\t\t\t}\n\t\t\t\tvar startIndex = page * count;\n\t\t\t\tvisibleList = content.slice(startIndex, startIndex + count);\n\t\t\t\treturn visibleList;\n\t\t\t},\n\t\t\t// getPages()\n\t\t\t// ==\n\t\t\t// Returns an array describing each page, listing index, whether\n\t\t\t// it is the first or last page, and the number of items returned.\n\t\t\t// Written to make custom page navigation easier.\n\t\t\tgetPages: function paginateGetPages() {\n\t\t\t\tvar pageList = [];\n\t\t\t\tvar content = getContent();\n\t\t\t\tvar numPages = this.getNumPages();\n\t\t\t\tfor (i = 0; i < numPages; i++) {\n\t\t\t\t\tpageList.push({\n\t\t\t\t\t\t\"count\": count,\n\t\t\t\t\t\t\"index\": i,\n\t\t\t\t\t\t\"first\": i === 0,\n\t\t\t\t\t\t\"last\": i === numPages - 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (pageList.length > 0) {\n\t\t\t\t\tpageList[pageList.length - 1].count = content.length % count;\n\t\t\t\t}\n\t\t\t\treturn pageList;\n\t\t\t},\n\t\t\t// getNumPages()\n\t\t\t// ==\n\t\t\t// Returns the number of pages based on number of items per page.\n\t\t\tgetNumPages: function paginateNumPages() {\n\t\t\t\treturn Math.ceil(getContent().length / count);\n\t\t\t},\n\t\t\t// getIsFirstPage()\n\t\t\t// ==\n\t\t\t// Returns true if the currently returned page is the first.\n\t\t\tgetIsFirstPage: function paginateIsFirstPage() {\n\t\t\t\treturn page === 0;\n\t\t\t},\n\t\t\t// getIsFirstPage()\n\t\t\t// ==\n\t\t\t// Returns true if the currently returned page is the last.\n\t\t\tgetIsLastPage: function paginateIsLastPage() {\n\t\t\t\treturn page === this.getNumPages() - 1;\n\t\t\t},\n\t\t\t// firstPage()\n\t\t\t// ==\n\t\t\t// Sets the page index to 0, or the first page.\n\t\t\t// Returns the current visible content.\n\t\t\tfirstPage: function paginateFirstPage() {\n\t\t\t\tpage = 0;\n\t\t\t\treturn this.getVisibleContent();\n\t\t\t},\n\t\t\t// prevPage()\n\t\t\t// ==\n\t\t\t// Sets the page index to the current - 1, or to itself\n\t\t\t// if on the first page.\n\t\t\t// Returns the current visible content.\n\t\t\tprevPage: function paginatePrevPage() {\n\t\t\t\tpage = !this.getIsFirstPage() ? page - 1 : page;\n\t\t\t\treturn this.getVisibleContent();\n\t\t\t},\n\t\t\t// nextPage()\n\t\t\t// ==\n\t\t\t// Sets the page index to the current + 1, or to itself\n\t\t\t// if on the last page.\n\t\t\t// Returns the current visible content.\n\t\t\tnextPage: function paginateNextPage() {\n\t\t\t\tpage = !this.getIsLastPage() ? page + 1 : page;\n\t\t\t\treturn this.getVisibleContent();\n\t\t\t},\n\t\t\t// firstPage()\n\t\t\t// ==\n\t\t\t// Sets the page index to `getNumPages() - 1`, or the last page.\n\t\t\t// Returns the current visible content.\n\t\t\tlastPage: function paginateLastPage() {\n\t\t\t\tpage = this.getNumPages() - 1;\n\t\t\t\treturn this.getVisibleContent();\n\t\t\t}\n\t\t};\n\t};\n\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine(function() {\n\t\t\treturn paginate;\n\t\t});\n\t} else if (typeof module !== \"undefined\" && module.exports) {\n\t\tmodule.exports = paginate;\n\t} else {\n\t\tthat.paginate = paginate;\n\t}\n\n\tfunction numberisInteger(value) {\n\t\treturn typeof value === \"number\" &&\n\t\t\tisFinite(value) &&\n\t\t\tMath.floor(value) === value;\n\t}\n\n}(this));\n"],"sourceRoot":"/source/"}